package main

import (
	"go/format"
	"log"
	"os"
	"regexp"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/ryanmab/rdap-go/internal/cmd/internal/bootstrap"
	"github.com/ryanmab/rdap-go/internal/query"
)

func main() {
	bootstrapResponse := bootstrap.FetchBootstrap(query.IPv6Query)

	log.Printf("Fetched IPv6 bootstrap data version %s published at %s. There are %d services", bootstrapResponse.Version, bootstrapResponse.Publication, len(bootstrapResponse.Services))

	f, err := os.Create("internal/registry/ipv6/bootstrap_generated.go")

	if err != nil {
		log.Fatal(err)
	}

	template, err := generate(bootstrapResponse)

	if err != nil {
		log.Fatal(err)
	}

	if _, err := f.Write(template); err != nil {
		log.Fatal(err)
	}

	if err := f.Close(); err != nil {
		log.Fatal(err)
	}

	log.Printf("Wrote IPv6 bootstrap data to internal/ipv6/bootstrap_generated.go")
}

// Generate the Go source code for the IPv4 bootstrap map based on the fetched data
// from IANA.
func generate(bootstrapResponse bootstrap.Response) ([]byte, error) {
	r := regexp.MustCompile("([a-f0-9]{1,4}):([a-f0-9]{0,4}):([a-f0-9]{0,4})[:]{0,1}([a-f0-9]{0,4})/([0-9]+)")

	ips := make([]string, 0)

	var boostrapData strings.Builder
	for _, service := range bootstrapResponse.Services {
		for _, ip := range service.Keys {
			ips = append(ips, ip)

			boostrapData.WriteString("\t\t\"" + ip + "\": {\n")
			for _, server := range service.Servers {
				boostrapData.WriteString("\t\t\t\"" + server + "\",\n")
			}
			boostrapData.WriteString("\t\t},\n")
		}
	}

	// Sort through the map, ordering the mapping in descending order, where the first entry is the smallest (most specific)
	// range, and the last entry is the largest (least specific) range.
	//
	// The sorting is important here as when performing lookups later, we want to ensure that the most specific
	// ranges are checked first and can therefore bail early when encountering a match.
	slices.SortFunc(ips, func(a, b string) int {
		partsA := r.FindStringSubmatch(a)
		partsB := r.FindStringSubmatch(b)

		// Extract the individual hextets of the IP ranges (i.e. 2001 e00 are the first two hextets of 2001:e00::/23)
		ipHextetsA := partsA[1 : len(partsA)-1]
		ipHextetsB := partsB[1 : len(partsB)-1]

		// Extract the subnet masks of the two IP ranges.
		subnetMaskA := partsA[len(partsA)-1]
		subnetMaskB := partsB[len(partsB)-1]

		subnetCompare := strings.Compare(subnetMaskB, subnetMaskA)

		if subnetCompare != 0 {
			// Order by subnet mask descending to begin with - this pushes more specific ranges to the top
			// of the list.
			return subnetCompare
		}

		// Now compare the actual hextets of the IP, in order of most significant to least significant.
		for i := 0; i < max(len(ipHextetsA), len(ipHextetsB)); i++ {
			if ipHextetsB[i] != "" && ipHextetsA[i] == "" {
				// A is more specific than B (by having more parts specified).
				return -1
			} else if ipHextetsA[i] != "" && ipHextetsB[i] == "" {
				// B is more specific than A (by having more parts specified).
				return 1
			} else if ipHextetsA[i] == "" && ipHextetsB[i] == "" {
				// Neither specifies this part, continue to next part until we encounter
				// a hextet which is specified.
				continue
			}

			hextetB, err := strconv.ParseInt(ipHextetsB[i], 16, 64)
			if err != nil {
				panic(err)
			}

			hextetA, err := strconv.ParseInt(ipHextetsA[i], 16, 64)
			if err != nil {
				panic(err)
			}

			if hextetA < hextetB {
				return 1
			} else if hextetA > hextetB {
				return -1
			}
		}

		return 0
	})

	var boostrapOrderedKeysData strings.Builder
	for _, ip := range ips {
		boostrapOrderedKeysData.WriteString("\t\"" + ip + "\",\n")
	}

	template := []byte(`
		package ipv6

        // DO NOT EDIT!
		//
		// This file is generated by internal/cmd/generate-ipv6-bootstrap.go

		// BootstrapAccessOrder is the IPv6 RDAP bootstrap data listed in descending order of specificity of IP range.
		//
		// The ordering is important to ensure that the most specific ranges are checked first during lookups.
		var BootstrapAccessOrder = []string{
			` + boostrapOrderedKeysData.String() + `
		}
		// Bootstrap is the IPv6 RDAP bootstrap data sourced from IANA.
		//
		// Source (version: ` + bootstrapResponse.Version + `, publication date: ` + bootstrapResponse.Publication.Format(time.RFC3339) + `): https://data.iana.org/rdap/ipv6.json
		var Bootstrap = map[string][]string{
			` + boostrapData.String() + `
		}
	`)

	return format.Source(template)
}
